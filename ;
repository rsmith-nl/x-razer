// file: razer-usb.c
// vim:fileencoding=utf-8:ft=c:tabstop=2
// This is free and unencumbered software released into the public domain.
//
// Author: R.F. Smith <rsmith@xs4all.nl>
// SPDX-License-Identifier: Unlicense
// Created: 2025-08-28 16:01:44 +0200
// Last modified: 2025-08-28T16:31:30+0200

#include <stdint.h>
#include <stdbool.h>
#include <libusb.h>

#include "razer-usb.h"


typedef struct {
  char product_name[80];
  libusb_device_handle *handle;
} USB_data;


typedef struct {
  uint8_t status;
  uint8_t transaction_id;
  uint16_t remaining_packets; /* Big Endian */
  uint8_t protocol_type; /*0x0*/
  uint8_t data_size;
  uint8_t command_class;
  uint8_t command_id;
  uint8_t arguments[80];
  uint8_t crc;/*xor'ed bytes of report*/
  uint8_t reserved; /*0x0*/
} Razer_report;


uint8_t calculate_crc(Razer_report *report) {
  uint8_t *_report = (uint8_t*)report;
  uint8_t crc = 0;
  for (int j = 2; j < 88; j++) {
    crc ^= _report[j];
  }
  return crc;
}

bool init_usb(USB_data *out) {
  if (out == 0) {
    return false;
  }
  if (libusb_init(0) != 0) {
    return false;
  }
  libusb_device **device_list;
  ssize_t device_count =  libusb_get_device_list(0, &device_list);
  if (device_count == 0) {
    return false;
  }
  libusb_device_descriptor desc = {0};
  bool rv = false;
  for (int32_t k = 0; k < device_count; k++) {
    if (libusb_get_device_descriptor(device_list[k], &desc) != 0) {
      break;
    }
    if (desc.idVendor != 0x1532 && desc.idProduct != 0x0228) {
      continue;
    }
    if (libusb_open(device_list[k], &out->handle) != 0) {
      out->handle = 0;
      break;
    }
    if (libusb_get_string_descriptor_ascii(out->handle, desc.iProduct,
        (uint8_t*)&out->product_name, 79) != 0) {
      rv = true;
      break;
    }
  }
  libusb_free_device_list(device_list, 1);
  return rv;
}

void finalize_usb(void) {
  libusb_exit(0);
}
